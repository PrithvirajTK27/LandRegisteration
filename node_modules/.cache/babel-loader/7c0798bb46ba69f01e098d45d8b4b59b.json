{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar token = require('./token.js');\n\nvar common = require('./common.js');\n\nvar _0uint = require('./0uint.js');\n\nvar MINOR_FALSE = 20;\nvar MINOR_TRUE = 21;\nvar MINOR_NULL = 22;\nvar MINOR_UNDEFINED = 23;\n\nfunction decodeUndefined(_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(\"\".concat(common.decodeErrPrefix, \" undefined values are not supported\"));\n  } else if (options.coerceUndefinedToNull === true) {\n    return new token.Token(token.Type.null, null, 1);\n  }\n\n  return new token.Token(token.Type.undefined, undefined, 1);\n}\n\nfunction decodeBreak(_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(\"\".concat(common.decodeErrPrefix, \" indefinite length items not allowed\"));\n  }\n\n  return new token.Token(token.Type.break, undefined, 1);\n}\n\nfunction createToken(value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(\"\".concat(common.decodeErrPrefix, \" NaN values are not supported\"));\n    }\n\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(\"\".concat(common.decodeErrPrefix, \" Infinity values are not supported\"));\n    }\n  }\n\n  return new token.Token(token.Type.float, value, bytes);\n}\n\nfunction decodeFloat16(data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options);\n}\n\nfunction decodeFloat32(data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options);\n}\n\nfunction decodeFloat64(data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options);\n}\n\nfunction encodeFloat(buf, token$1, options) {\n  var float = token$1.value;\n\n  if (float === false) {\n    buf.push([token.Type.float.majorEncoded | MINOR_FALSE]);\n  } else if (float === true) {\n    buf.push([token.Type.float.majorEncoded | MINOR_TRUE]);\n  } else if (float === null) {\n    buf.push([token.Type.float.majorEncoded | MINOR_NULL]);\n  } else if (float === undefined) {\n    buf.push([token.Type.float.majorEncoded | MINOR_UNDEFINED]);\n  } else {\n    var decoded;\n    var success = false;\n\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float);\n      decoded = readFloat16(ui8a, 1);\n\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 249;\n        buf.push(ui8a.slice(0, 3));\n        success = true;\n      } else {\n        encodeFloat32(float);\n        decoded = readFloat32(ui8a, 1);\n\n        if (float === decoded) {\n          ui8a[0] = 250;\n          buf.push(ui8a.slice(0, 5));\n          success = true;\n        }\n      }\n    }\n\n    if (!success) {\n      encodeFloat64(float);\n      decoded = readFloat64(ui8a, 1);\n      ui8a[0] = 251;\n      buf.push(ui8a.slice(0, 9));\n    }\n  }\n}\n\nencodeFloat.encodedSize = function encodedSize(token, options) {\n  var float = token.value;\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1;\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float);\n    var decoded = readFloat16(ui8a, 1);\n\n    if (float === decoded || Number.isNaN(float)) {\n      return 3;\n    }\n\n    encodeFloat32(float);\n    decoded = readFloat32(ui8a, 1);\n\n    if (float === decoded) {\n      return 5;\n    }\n  }\n\n  return 9;\n};\n\nvar buffer = new ArrayBuffer(9);\nvar dataView = new DataView(buffer, 1);\nvar ui8a = new Uint8Array(buffer, 0);\n\nfunction encodeFloat16(inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 31744, false);\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 64512, false);\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 32256, false);\n  } else {\n    dataView.setFloat32(0, inp);\n    var valu32 = dataView.getUint32(0);\n    var exponent = (valu32 & 2139095040) >> 23;\n    var mantissa = valu32 & 8388607;\n\n    if (exponent === 255) {\n      dataView.setUint16(0, 31744, false);\n    } else if (exponent === 0) {\n      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);\n    } else {\n      var logicalExponent = exponent - 127;\n\n      if (logicalExponent < -24) {\n        dataView.setUint16(0, 0);\n      } else if (logicalExponent < -14) {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);\n      } else {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);\n      }\n    }\n  }\n}\n\nfunction readFloat16(ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(\"\".concat(common.decodeErrPrefix, \" not enough data for float16\"));\n  }\n\n  var half = (ui8a[pos] << 8) + ui8a[pos + 1];\n\n  if (half === 31744) {\n    return Infinity;\n  }\n\n  if (half === 64512) {\n    return -Infinity;\n  }\n\n  if (half === 32256) {\n    return NaN;\n  }\n\n  var exp = half >> 10 & 31;\n  var mant = half & 1023;\n  var val;\n\n  if (exp === 0) {\n    val = mant * Math.pow(2, -24);\n  } else if (exp !== 31) {\n    val = (mant + 1024) * Math.pow(2, exp - 25);\n  } else {\n    val = mant === 0 ? Infinity : NaN;\n  }\n\n  return half & 32768 ? -val : val;\n}\n\nfunction encodeFloat32(inp) {\n  dataView.setFloat32(0, inp, false);\n}\n\nfunction readFloat32(ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(\"\".concat(common.decodeErrPrefix, \" not enough data for float32\"));\n  }\n\n  var offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);\n}\n\nfunction encodeFloat64(inp) {\n  dataView.setFloat64(0, inp, false);\n}\n\nfunction readFloat64(ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(\"\".concat(common.decodeErrPrefix, \" not enough data for float64\"));\n  }\n\n  var offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);\n}\n\nencodeFloat.compareTokens = _0uint.encodeUint.compareTokens;\nexports.decodeBreak = decodeBreak;\nexports.decodeFloat16 = decodeFloat16;\nexports.decodeFloat32 = decodeFloat32;\nexports.decodeFloat64 = decodeFloat64;\nexports.decodeUndefined = decodeUndefined;\nexports.encodeFloat = encodeFloat;","map":null,"metadata":{},"sourceType":"script"}