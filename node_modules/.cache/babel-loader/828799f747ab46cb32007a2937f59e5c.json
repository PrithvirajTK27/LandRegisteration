{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\prith\\\\Desktop\\\\New folder (5)\\\\starter_kit-master\\\\LandRegisteration\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\prith\\\\Desktop\\\\New folder (5)\\\\starter_kit-master\\\\LandRegisteration\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\prith\\\\Desktop\\\\New folder (5)\\\\starter_kit-master\\\\LandRegisteration\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\prith\\\\Desktop\\\\New folder (5)\\\\starter_kit-master\\\\LandRegisteration\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\prith\\\\Desktop\\\\New folder (5)\\\\starter_kit-master\\\\LandRegisteration\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\prith\\\\Desktop\\\\New folder (5)\\\\starter_kit-master\\\\LandRegisteration\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar token = require('../token.js');\n\nvar encode$1 = require('../encode.js');\n\nvar common = require('../common.js');\n\nvar byteUtils = require('../byte-utils.js');\n\nvar JSONEncoder =\n/*#__PURE__*/\nfunction (_Array) {\n  _inherits(JSONEncoder, _Array);\n\n  function JSONEncoder() {\n    var _this;\n\n    _classCallCheck(this, JSONEncoder);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(JSONEncoder).call(this));\n    _this.inRecursive = [];\n    return _this;\n  }\n\n  _createClass(JSONEncoder, [{\n    key: \"prefix\",\n    value: function prefix(buf) {\n      var recurs = this.inRecursive[this.inRecursive.length - 1];\n\n      if (recurs) {\n        if (recurs.type === token.Type.array) {\n          recurs.elements++;\n\n          if (recurs.elements !== 1) {\n            buf.push([44]);\n          }\n        }\n\n        if (recurs.type === token.Type.map) {\n          recurs.elements++;\n\n          if (recurs.elements !== 1) {\n            if (recurs.elements % 2 === 1) {\n              buf.push([44]);\n            } else {\n              buf.push([58]);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: token.Type.uint.major,\n    value: function value(buf, token) {\n      this.prefix(buf);\n      var is = String(token.value);\n      var isa = [];\n\n      for (var i = 0; i < is.length; i++) {\n        isa[i] = is.charCodeAt(i);\n      }\n\n      buf.push(isa);\n    }\n  }, {\n    key: token.Type.negint.major,\n    value: function value(buf, token$1) {\n      this[token.Type.uint.major](buf, token$1);\n    }\n  }, {\n    key: token.Type.bytes.major,\n    value: function value(_buf, _token) {\n      throw new Error(\"\".concat(common.encodeErrPrefix, \" unsupported type: Uint8Array\"));\n    }\n  }, {\n    key: token.Type.string.major,\n    value: function value(buf, token) {\n      this.prefix(buf);\n      var byts = byteUtils.fromString(JSON.stringify(token.value));\n      buf.push(byts.length > 32 ? byteUtils.asU8A(byts) : byts);\n    }\n  }, {\n    key: token.Type.array.major,\n    value: function value(buf, _token) {\n      this.prefix(buf);\n      this.inRecursive.push({\n        type: token.Type.array,\n        elements: 0\n      });\n      buf.push([91]);\n    }\n  }, {\n    key: token.Type.map.major,\n    value: function value(buf, _token) {\n      this.prefix(buf);\n      this.inRecursive.push({\n        type: token.Type.map,\n        elements: 0\n      });\n      buf.push([123]);\n    }\n  }, {\n    key: token.Type.tag.major,\n    value: function value(_buf, _token) {}\n  }, {\n    key: token.Type.float.major,\n    value: function value(buf, token$1) {\n      if (token$1.type.name === 'break') {\n        var recurs = this.inRecursive.pop();\n\n        if (recurs) {\n          if (recurs.type === token.Type.array) {\n            buf.push([93]);\n          } else if (recurs.type === token.Type.map) {\n            buf.push([125]);\n          } else {\n            throw new Error('Unexpected recursive type; this should not happen!');\n          }\n\n          return;\n        }\n\n        throw new Error('Unexpected break; this should not happen!');\n      }\n\n      if (token$1.value === undefined) {\n        throw new Error(\"\".concat(common.encodeErrPrefix, \" unsupported type: undefined\"));\n      }\n\n      this.prefix(buf);\n\n      if (token$1.type.name === 'true') {\n        buf.push([116, 114, 117, 101]);\n        return;\n      } else if (token$1.type.name === 'false') {\n        buf.push([102, 97, 108, 115, 101]);\n        return;\n      } else if (token$1.type.name === 'null') {\n        buf.push([110, 117, 108, 108]);\n        return;\n      }\n\n      var is = String(token$1.value);\n      var isa = [];\n      var dp = false;\n\n      for (var i = 0; i < is.length; i++) {\n        isa[i] = is.charCodeAt(i);\n\n        if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n          dp = true;\n        }\n      }\n\n      if (!dp) {\n        isa.push(46);\n        isa.push(48);\n      }\n\n      buf.push(isa);\n    }\n  }]);\n\n  return JSONEncoder;\n}(_wrapNativeSuper(Array));\n\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(\"\".concat(common.encodeErrPrefix, \" complex map keys are not supported\"));\n  }\n\n  var keyToken1 = e1[0];\n  var keyToken2 = e2[0];\n\n  if (keyToken1.type !== token.Type.string || keyToken2.type !== token.Type.string) {\n    throw new Error(\"\".concat(common.encodeErrPrefix, \" non-string map keys are not supported\"));\n  }\n\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n\n  throw new Error(\"\".concat(common.encodeErrPrefix, \" unexpected duplicate map keys, this is not supported\"));\n}\n\nvar defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter: mapSorter\n};\n\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encode$1.encodeCustom(data, new JSONEncoder(), options);\n}\n\nexports.encode = encode;","map":null,"metadata":{},"sourceType":"script"}